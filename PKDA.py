import hashlib
import json
from datetime import datetime
import KeyPairs_Generation
import gmpy2
import time
import random
from typing import Dict, Any
class PKDA:
    res = []

    def __init__(self):
        self.clients_public_key = {}  # dcitionary for stoeing client public key with their ids

    # Define a function to generate nonces
    def generate_nonce(self):
        return random.randint(0, 2 ** 32 - 1)

    # Define a function to get the current timestamp
    def get_timestamp(self):
        return int(time.time())

    def add_client(self, client_id, public_key):
        self.clients_public_key[client_id] = public_key

    # for generating a key pair using RSA systematic scheme defined in RSA file.
    def generate_pkda_keys(self):
        print('\n')
        print("Enter pkda's keys : ")
        pkda_public, pkda_private = KeyPairs_Generation.generate_keypair(1)
        self.res.append(pkda_public)
        self.res.append(pkda_private)
        return self.res

# for getting public key associated with the given client id
    def get_public_key(self, client_id):
        if client_id in self.clients_public_key:
            return self.clients_public_key[client_id]
        else:
            return None


    # function for encryption of the respinse fields
    def encrypt(self, value, key):
        res = []
        # handling strings and alphabets
        if key == 'type' or key == 'sender' or key == 'receiver' or key == 'client_id' or key == 'timeStamp':
            test_list = [value]
            r = [ord(ele) for sub in test_list for ele in sub]
            for i in range(0, len(r)):
                res.append(((r[i]) ** self.res[1][0]) % self.res[1][1])
            return res
        # for handling numericals
        else:
            res2 = ""
            if key == 'nonce' or key == 'encrypted_public_key':
                res2 += str((value ** self.res[1][0]) % self.res[1][1])
                return res2
            else:
                return value

# for encrypting whole fields of response generated by PKDA
    def encrypt_response(self, response):
        nelst=[]

        for i in response:
            if i == 'encrypted_public_key':
                pub = response[i][0]
                whole = response[i][1]
                r = self.encrypt(pub, 'encrypted_public_key')
                e = self.encrypt(whole, 'encrypted_public_key')
                nelst.append(r)
                nelst.append(e)
                response[i] = nelst
            else:
                temp = self.encrypt(response[i], i)
                response[i] = temp
        return response

# call from client to PKDA for asking of Public Key of other client to which connection needs to be esthablished
    def handle_request(self, request):
        if request['type'] == 'public_key_request':
            client_id = request['client_id']
            duration = request['duration']
            public_key = self.get_public_key(client_id)
            nonce = request['nonce']
            time_stamp = request['timeStamp']
            if public_key:
                response = {
                    'type': 'public_key_response',
                    'sender': 'pkda',
                    'receiver': request['sender'],
                    'client_id': client_id,
                    'nonce': nonce,
                    'timeStamp': time_stamp,
                    'duration': duration,
                    'encrypted_public_key': list(public_key),
                    'signature': '',
                    'hash': ''
                }
                encrypted_response_using_private_key = self.encrypt_response(response)
                hash_response = self.dict_hash(response)
                signature = self.Calculate_Signature(hash_response)
                print("Hash of the response ...... :", "  ", hash_response)
                response['signature'] = signature
                response['hash'] = hash_response
                return encrypted_response_using_private_key
        return None
 # for generating signature for authentication of the message received for the Client Public Key pair.
    def dict_hash(self, dictionary: Dict[str, Any]) -> bytes:
        """MD5 hash of a dictionary."""
        # for generating a hash code of the response to be sent or received
        dhash = hashlib.md5()
        encoded = json.dumps(dictionary, sort_keys=True).encode()
        dhash.update(encoded)
        return dhash.digest()

    def Calculate_Signature(self, hash_response):
        r = []
        for c in hash_response:
            r.append(c)
        signature = [gmpy2.powmod(c, self.res[1][0], self.res[1][1]) for c in r]
        return signature

# for getting cross tele of details from PKDA about the client added to it
    def Owner_details_from_pkda(self, client_id):
        time_stamp = str(datetime.now())[:19]
        duration = list(time_stamp)
        duration[14] = str(int(duration[14]) + 2)
        duration = ''.join(duration)
        print("Duration :", duration)
        # time_val = datetime.datetime.now()
        print("Time :", (str(time_stamp)))
        response = {
            'type': 'public_key_response',
            'sender': 'pkda',
            'client_id': client_id,
            'timeStamp': time_stamp,
            'duration': duration,
            'own_public_key': self.get_public_key(client_id),
            'signature': '',
            'hash': ''
        }
        hash_response = self.dict_hash(response)
        signature = self.Calculate_Signature(hash_response)
        print("Hash of the response ...... :", "  ", hash_response)
        response['signature'] = signature
        response['hash'] = hash_response
        return response